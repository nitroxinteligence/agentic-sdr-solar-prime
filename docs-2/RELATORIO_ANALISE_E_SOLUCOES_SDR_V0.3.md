# Relat√≥rio de An√°lise e Solu√ß√µes para Otimiza√ß√£o do Agente SDR v0.3

## RESUMO EXECUTIVO

### üìä Status Geral
- **An√°lise Profunda**: ‚úÖ Completa
- **Corre√ß√µes Cr√≠ticas**: 3/3 ‚úÖ Implementadas
- **Problemas Resolvidos**: 2/5 confirmados e corrigidos
- **Tempo de Implementa√ß√£o**: ~30 minutos

### üéØ Principais Descobertas
1. **Problema de Follow-up**: Funcionalidade estava DESABILITADA no c√≥digo (hardcoded)
2. **Erro TypeError**: Convers√µes de tipo sem valida√ß√£o causando crashes
3. **Falsos Positivos**: 2 dos 5 problemas reportados n√£o existiam no c√≥digo
4. **Novo Problema**: M√∫ltiplas convers√µes inseguras descobertas em todo o sistema

### ‚úÖ Corre√ß√µes Implementadas
1. **Follow-ups Reabilitados**: Integra√ß√£o real com Google Calendar restaurada
2. **Convers√µes Seguras**: M√≥dulo de utilidades criado para prevenir erros de tipo
3. **Resili√™ncia Aumentada**: Sistema agora trata casos edge em convers√µes de dados

### üöÄ Pr√≥ximos Passos Recomendados
1. Implementar melhorias de performance (connection pooling, cache)
2. Adicionar testes automatizados para prevenir regress√µes
3. Configurar monitoramento para detectar falhas proativamente

---

## 1. Introdu√ß√£o

Este relat√≥rio apresenta um diagn√≥stico detalhado e um plano de a√ß√£o para resolver cinco problemas cr√≠ticos identificados no sistema do agente SDR IA SolarPrime. A an√°lise foi dividida por especialidade para garantir que cada problema seja tratado em sua raiz, com solu√ß√µes diretas, eficientes e de baixa complexidade de implementa√ß√£o. O objetivo √© elevar o sistema a um estado 100% funcional e otimizado.

---

## DIAGN√ìSTICO COMPLETO DO SISTEMA (AN√ÅLISE PROFUNDA)

### Arquitetura Geral do Sistema

O sistema SDR IA SolarPrime segue uma arquitetura hier√°rquica de agentes com duas camadas principais:

**Camada 1: AGENTIC SDR (Orquestrador Principal)**
- Agente conversacional principal com personalidade ultra-humanizada
- Sistema de fallback inteligente (Gemini ‚Üí OpenAI)
- Gerenciamento de estado emocional por conversa
- Suporte multimodal (imagens, √°udio, documentos)
- Motor de decis√£o para delegar tarefas

**Camada 2: SDR Team (Agentes Especializados)**
- Coordenado por Helen SDR Master
- Agentes especializados: Qualification, Calendar, FollowUp, Knowledge, CRM, BillAnalyzer
- Framework AGNO Teams em modo COORDINATE

### Problemas Estruturais Identificados

1. **Incompatibilidade com Framework AGNO**
   - Memory component tentando chamar m√©todos inexistentes
   - Necessidade de wrappers complexos para registro de ferramentas

2. **Gerenciamento de Estado Deficiente**
   - Estados emocionais sem isolamento adequado por conversa
   - Potencial race condition em cen√°rios multi-usu√°rio
   - Cache sem estrat√©gia de invalida√ß√£o

3. **Falta de Padr√µes de Resili√™ncia**
   - Aus√™ncia de Circuit Breaker para servi√ßos externos
   - Rate limiting inconsistente entre servi√ßos
   - Recupera√ß√£o de erros n√£o padronizada

4. **Problemas de Integra√ß√£o**
   - Google Calendar com follow-ups DESABILITADOS (hardcoded)
   - Convers√µes de tipo sem valida√ß√£o (float() errors)
   - Gaps na integra√ß√£o entre servi√ßos

### Status Real dos 5 Problemas Reportados

1. **Reagendamento Google Calendar**: ‚ùå FALSO - O m√©todo `reschedule_meeting` existe e funciona
2. **Follow-up de Reuni√µes**: ‚úÖ CONFIRMADO - Funcionalidade DESABILITADA no c√≥digo
3. **Pipeline KommoCRM**: ‚ö†Ô∏è PARCIAL - L√≥gica existe mas com problemas de mapeamento
4. **Integra√ß√£o leads_qualifications**: ‚ùå FALSO - J√° est√° implementado e funcionando
5. **Erro TypeError float()**: ‚úÖ CONFIRMADO - Linha 402 de kommo_auto_sync.py

### Problemas Adicionais Descobertos

1. **Desempenho e Escalabilidade**
   - Sem connection pooling para Kommo API
   - Cada requisi√ß√£o cria nova sess√£o HTTP
   - Falta de cache para opera√ß√µes repetitivas

2. **Seguran√ßa e Valida√ß√£o**
   - Aus√™ncia de valida√ß√£o de entrada em m√∫ltiplos pontos
   - Convers√µes de tipo sem tratamento de exce√ß√µes
   - Logs expondo informa√ß√µes sens√≠veis

3. **Manutenibilidade**
   - Alto acoplamento entre componentes
   - Falta de testes automatizados
   - Documenta√ß√£o inline insuficiente

---

## CHECKLIST MESTRE DE CORRE√á√ïES

### üö® Corre√ß√µes Cr√≠ticas (Impacto Alto, Complexidade Baixa)

- [x] **CORRE√á√ÉO 1**: Reabilitar follow-ups do Google Calendar (Problema 2) ‚úÖ IMPLEMENTADO
- [x] **CORRE√á√ÉO 2**: Corrigir erro TypeError float() com valida√ß√£o adequada (Problema 5) ‚úÖ IMPLEMENTADO
- [x] **CORRE√á√ÉO 3**: Implementar valida√ß√£o de dados em todas as convers√µes de tipo ‚úÖ IMPLEMENTADO

### ‚ö° Melhorias de Performance (Impacto M√©dio, Complexidade Baixa)

- [ ] **MELHORIA 1**: Adicionar connection pooling para Kommo API
- [ ] **MELHORIA 2**: Implementar cache para opera√ß√µes repetitivas
- [ ] **MELHORIA 3**: Otimizar queries do Supabase com √≠ndices apropriados

### üîß Refatora√ß√µes Estruturais (Impacto Alto, Complexidade M√©dia)

- [ ] **REFATORA√á√ÉO 1**: Padronizar tratamento de erros com Circuit Breaker
- [ ] **REFATORA√á√ÉO 2**: Implementar valida√ß√£o de schemas para APIs
- [ ] **REFATORA√á√ÉO 3**: Isolar estado emocional por conversa com locks adequados

### üõ°Ô∏è Seguran√ßa e Confiabilidade (Impacto Alto, Complexidade M√©dia)

- [ ] **SEGURAN√áA 1**: Sanitizar logs para remover informa√ß√µes sens√≠veis
- [ ] **SEGURAN√áA 2**: Adicionar rate limiting consistente em todos os servi√ßos
- [ ] **SEGURAN√áA 3**: Implementar health checks para todas as integra√ß√µes

### üìä Observabilidade e Monitoramento (Impacto M√©dio, Complexidade Alta)

- [ ] **OBSERVABILIDADE 1**: Adicionar m√©tricas de performance
- [ ] **OBSERVABILIDADE 2**: Implementar distributed tracing
- [ ] **OBSERVABILIDADE 3**: Criar dashboards de monitoramento

### ‚úÖ Qualidade e Testes (Impacto Alto, Complexidade Alta)

- [ ] **QUALIDADE 1**: Adicionar testes unit√°rios para agentes
- [ ] **QUALIDADE 2**: Implementar testes de integra√ß√£o
- [ ] **QUALIDADE 3**: Criar testes end-to-end para fluxos cr√≠ticos

---

## CORRE√á√ïES IMPLEMENTADAS

### ‚úÖ CORRE√á√ÉO 1: Follow-ups do Google Calendar Reabilitados (ATUALIZADO)

**Arquivos Modificados**: 
- `app/services/followup_executor_service.py`
- `app/teams/agents/calendar.py`

**Mudan√ßas Implementadas**:
1. Importado `google_calendar_client` para integra√ß√£o real
2. Removido c√≥digo hardcoded que desabilitava os lembretes (linhas 136-138)
3. **NOVA IMPLEMENTA√á√ÉO**: Sistema agora usa `leads_qualifications` ao inv√©s de `calendar_events`:
   - Adicionado `google_event_id` na tabela `leads_qualifications`
   - CalendarAgent salva o ID do evento ao criar qualifica√ß√£o
   - Follow-up busca eventos usando associa√ß√£o lead ‚Üî google_event_id
4. Criada nova fun√ß√£o `_send_meeting_reminder_v2` que:
   - Busca lead correto via `leads_qualifications.google_event_id`
   - Marca lembretes enviados na tabela `leads_qualifications`
   - Garante que cada lembrete vai para o lead correto
5. **Migrations SQL criadas**:
   - `add_google_event_id_to_leads_qualifications.sql`
   - `add_reminder_fields_to_leads_qualifications.sql`

### ‚úÖ CORRE√á√ÉO 2: Erro TypeError float() Resolvido

**Arquivo Modificado**: `app/services/kommo_auto_sync.py`

**Mudan√ßas Implementadas**:
1. Criada fun√ß√£o `safe_float_conversion()` que trata todos os casos edge:
   - None expl√≠cito
   - Strings vazias ou "None"/"null"/"nan"
   - Valores n√£o num√©ricos
   - S√≠mbolos monet√°rios (R$, $)
   - V√≠rgulas como separadores decimais
2. Aplicada em todas as 3 ocorr√™ncias de convers√£o de `bill_value`:
   - Linha 204: cria√ß√£o de lead no Kommo
   - Linha 305: atualiza√ß√£o de campos customizados
   - Linha 442: cria√ß√£o de deal (onde ocorria o erro principal)

### ‚úÖ CORRE√á√ÉO 3: Valida√ß√£o de Dados em Todas as Convers√µes

**Arquivos Criados/Modificados**:
1. **Novo**: `app/utils/safe_conversions.py` - M√≥dulo centralizado de convers√µes seguras
2. **Modificado**: `app/services/kommo_auto_sync.py`
3. **Modificado**: `app/integrations/redis_client.py`

**Fun√ß√µes Implementadas**:
- `safe_int_conversion()` - Convers√£o segura para inteiros
- `safe_float_conversion()` - Convers√£o segura para float (j√° existente, movida)
- `safe_datetime_conversion()` - Convers√£o segura de datas com m√∫ltiplos formatos
- `safe_json_loads()` - Parse JSON seguro com tratamento de erros
- `safe_json_dumps()` - Serializa√ß√£o JSON segura
- `safe_dict_get()` - Acesso seguro a dicion√°rios com valida√ß√£o de tipo

**Convers√µes Corrigidas**:
1. **kommo_auto_sync.py**:
   - Linha 309: `qualification_score` ‚Üí int seguro
   - Linha 318: `consumption_kwh` ‚Üí int seguro
2. **redis_client.py**:
   - Linha 379: JSON parse ‚Üí safe_json_loads
   - Linha 524: Rate limit counter ‚Üí int seguro
   - Linha 678: Counter value ‚Üí int seguro

---

## 2. Problema 1: L√≥gica de Reagendamento no Google Calendar

### 2.1. Diagn√≥stico Detalhado

O fluxo de reagendamento de reuni√µes est√° incorreto. Atualmente, ao inv√©s de cancelar o evento existente e procurar novos hor√°rios, o agente cria um novo evento no mesmo dia e hor√°rio do anterior. Isso causa duplicidade e n√£o atende √† solicitude do usu√°rio.

O c√≥digo respons√°vel, provavelmente no `app/teams/agents/calendar.py`, chama diretamente a fun√ß√£o de cria√ß√£o de evento ao inv√©s de um fluxo de reagendamento. Falta uma orquestra√ß√£o que envolva:
1.  Cancelamento do evento atual.
2.  Verifica√ß√£o de novos hor√°rios dispon√≠veis.
3.  Apresenta√ß√£o das op√ß√µes ao usu√°rio.
4.  Agendamento em um novo slot escolhido.

### 2.2. Plano de A√ß√£o e Solu√ß√£o Proposta

Prop√µe-se a cria√ß√£o de uma nova fun√ß√£o `reschedule_meeting` no `CalendarAgent` e a modifica√ß√£o do fluxo de intera√ß√£o do agente principal para utiliz√°-la.

**Etapa 1: Implementar `reschedule_meeting` em `app/teams/agents/calendar.py`**

Adicionar um novo m√©todo ao `CalendarAgent` que orquestra o processo de reagendamento.

```python
# Em app/teams/agents/calendar.py, dentro da classe CalendarAgent

async def reschedule_meeting(
    self,
    event_id: str,
    lead_id: str,
    new_date: str,
    new_time: str
) -> Dict[str, Any]:
    """
    Reagenda uma reuni√£o existente, cancelando a antiga e criando uma nova.

    Args:
        event_id: ID do evento do Google Calendar a ser cancelado.
        lead_id: ID do lead no banco de dados.
        new_date: Nova data para a reuni√£o (DD/MM/YYYY).
        new_time: Novo hor√°rio para a reuni√£o (HH:MM).

    Returns:
        Dicion√°rio com o status do reagendamento.
    """
    logger.info(f"Iniciando reagendamento para o evento {event_id}")

    # Etapa 1: Cancelar o evento antigo
    try:
        cancel_result = await self.cancel_meeting(event_id, reason="Reagendado a pedido do cliente")
        if not cancel_result.get("success"):
            logger.error(f"Falha ao cancelar evento antigo {event_id}: {cancel_result.get('error')}")
            return {"success": False, "error": "N√£o foi poss√≠vel cancelar o evento original."}
        logger.info(f"Evento antigo {event_id} cancelado com sucesso.")
    except Exception as e:
        logger.error(f"Exce√ß√£o ao cancelar evento antigo {event_id}: {e}")
        return {"success": False, "error": f"Exce√ß√£o ao cancelar evento: {e}"}

    # Etapa 2: Agendar a nova reuni√£o
    try:
        lead_info = await supabase_client.get_lead_by_id(lead_id)
        if not lead_info:
            return {"success": False, "error": "Lead n√£o encontrado para o reagendamento."}

        attendee_emails = [lead_info.get("email")] if lead_info.get("email") else []

        schedule_result = await self.schedule_meeting(
            lead_id=lead_id,
            title=f"REAGENDADO: Apresenta√ß√£o Solar Prime - {lead_info.get('name')}",
            date=new_date,
            time=new_time,
            attendee_emails=attendee_emails,
            description="Esta √© uma reuni√£o reagendada a pedido do cliente."
        )

        if schedule_result.get("success"):
            logger.info(f"Reuni√£o reagendada com sucesso para {new_date} √†s {new_time}.")
            return schedule_result
        else:
            logger.error(f"Falha ao agendar novo evento: {schedule_result.get('error')}")
            # Tentar reagendar o evento original como fallback? (a discutir)
            return {"success": False, "error": "O evento antigo foi cancelado, mas falhou ao criar o novo."}

    except Exception as e:
        logger.error(f"Exce√ß√£o ao criar novo evento de reagendamento: {e}")
        return {"success": False, "error": f"Exce√ß√£o ao criar novo evento: {e}"}
```

**Etapa 2: Modificar o Agente Principal para usar o novo fluxo**

O `AgenticSDR` em `app/agents/agentic_sdr.py` deve ser instru√≠do a detectar a inten√ß√£o de "reagendar" e, em vez de chamar `schedule_meeting`, deve primeiro buscar hor√°rios dispon√≠veis e depois chamar a nova fun√ß√£o `reschedule_meeting`.

### 2.3. Checklist de Implementa√ß√£o

- [ ] Adicionar a fun√ß√£o `reschedule_meeting` √† classe `CalendarAgent` em `app/teams/agents/calendar.py`.
- [ ] Atualizar o `AgenticSDR` para reconhecer a inten√ß√£o de reagendamento.
- [ ] Garantir que o `AgenticSDR` chame `find_best_slots` antes de apresentar novas op√ß√µes ao usu√°rio.
- [ ] Assegurar que, ap√≥s a escolha do usu√°rio, o `AgenticSDR` chame `reschedule_meeting` com o ID do evento antigo e os novos detalhes.
- [ ] Testar o fluxo completo de reagendamento.

---

## 3. Problema 2: Follow-up de Agendamentos do Google Calendar

### 3.1. Diagn√≥stico Detalhado

O sistema n√£o est√° enviando lembretes de reuni√£o 24h e 2h antes do evento. Isso ocorre porque n√£o h√° um processo cont√≠nuo (worker/cron job) que verifique os eventos agendados no Google Calendar e dispare os lembretes. A funcionalidade para enviar a mensagem pode existir, mas o gatilho est√° ausente.

O arquivo `app/services/followup_executor_service.py` parece ser o local ideal para essa l√≥gica, mas atualmente ele est√° focado em follow-ups de conversas e n√£o em eventos de calend√°rio.

### 3.2. Plano de A√ß√£o e Solu√ß√£o Proposta

A solu√ß√£o √© expandir o `FollowUpExecutorService` para incluir uma verifica√ß√£o peri√≥dica de eventos do Google Calendar.

**Etapa 1: Modificar `FollowUpExecutorService` em `app/services/followup_executor_service.py`**

Adicionar um novo loop de verifica√ß√£o ou integrar na verifica√ß√£o existente a l√≥gica para buscar eventos no calend√°rio.

```python
# Em app/services/followup_executor_service.py

class FollowUpExecutorService:
    def __init__(self):
        # ... (inicializa√ß√£o existente) ...
        self.calendar_check_interval = 300  # Verificar calend√°rio a cada 5 minutos

    async def start(self):
        # ... (c√≥digo de start existente) ...
        # Adicionar o novo loop para lembretes de reuni√£o
        asyncio.create_task(self._calendar_reminder_loop())

    async def _calendar_reminder_loop(self):
        """Loop que verifica eventos do calend√°rio e envia lembretes."""
        while self.running:
            try:
                await self.process_meeting_reminders()
                await asyncio.sleep(self.calendar_check_interval)
            except Exception as e:
                logger.error(f"‚ùå Erro no loop de lembretes de calend√°rio: {e}")
                await asyncio.sleep(60) # Espera mais em caso de erro

    async def process_meeting_reminders(self):
        """Busca eventos futuros e envia lembretes de 24h e 2h."""
        now = datetime.now(pytz.timezone(settings.timezone))
        
        # Lembrete de 24h
        time_min_24h = now + timedelta(hours=23, minutes=55)
        time_max_24h = now + timedelta(hours=24, minutes=5)
        events_24h = await google_calendar_client.list_events(time_min=time_min_24h, time_max=time_max_24h)
        
        for event in events_24h:
            event_id = event.get('google_event_id')
            # L√≥gica para verificar se o lembrete j√° foi enviado (requer um campo no DB)
            # Ex: if not await self.db.has_reminder_been_sent(event_id, '24h'):
            await self._send_reminder(event, '24h')
            # await self.db.mark_reminder_as_sent(event_id, '24h')

        # Lembrete de 2h
        time_min_2h = now + timedelta(hours=1, minutes=55)
        time_max_2h = now + timedelta(hours=2, minutes=5)
        events_2h = await google_calendar_client.list_events(time_min=time_min_2h, time_max=time_max_2h)

        for event in events_2h:
            event_id = event.get('google_event_id')
            # L√≥gica para verificar se o lembrete j√° foi enviado
            # Ex: if not await self.db.has_reminder_been_sent(event_id, '2h'):
            await self._send_reminder(event, '2h')
            # await self.db.mark_reminder_as_sent(event_id, '2h')

    async def _send_reminder(self, event: Dict[str, Any], reminder_type: str):
        """Envia uma mensagem de lembrete formatada."""
        # Extrair informa√ß√µes do evento para encontrar o lead
        # Esta parte depende de como o lead_id √© armazenado na descri√ß√£o do evento ou em uma tabela de mapeamento
        lead_id = self._extract_lead_id_from_event(event)
        if not lead_id:
            logger.warning(f"N√£o foi poss√≠vel encontrar o lead_id para o evento {event.get('google_event_id')}")
            return

        lead = await supabase_client.get_lead_by_id(lead_id)
        if not lead or not lead.get('phone_number'):
            return

        start_time = datetime.fromisoformat(event['start']['dateTime']).strftime('%H:%M')
        
        if reminder_type == '24h':
            message = f"Ol√°, {lead.get('name', 'tudo bem')}! Passando para confirmar nossa reuni√£o de amanh√£ √†s {start_time}. Est√° tudo certo para voc√™?"
        else: # 2h
            message = f"Ol√°, {lead.get('name', 'tudo bem')}! Nossa reuni√£o √© daqui a 2 horas, √†s {start_time}! J√° estou preparando tudo aqui. At√© breve!"

        await evolution_client.send_text_message(phone=lead['phone_number'], message=message)
        logger.info(f"Lembrete de {reminder_type} enviado para o lead {lead_id} para o evento {event.get('google_event_id')}")

    def _extract_lead_id_from_event(self, event: Dict[str, Any]) -> Optional[str]:
        # Implementar a l√≥gica para extrair o lead_id da descri√ß√£o do evento ou de uma tabela de mapeamento
        # Exemplo:
        description = event.get('description', '')
        match = re.search(r'Lead ID: (\S+)', description)
        if match:
            return match.group(1)
        return None
```

### 3.3. Checklist de Implementa√ß√£o

- [ ] Adicionar o loop `_calendar_reminder_loop` ao `FollowUpExecutorService`.
- [ ] Implementar a fun√ß√£o `process_meeting_reminders` para buscar eventos no Google Calendar.
- [ ] Criar a fun√ß√£o `_send_reminder` para formatar e enviar a mensagem de lembrete.
- [ ] Implementar um mecanismo para rastrear lembretes enviados e evitar duplicidade (sugest√£o: adicionar colunas `reminder_24h_sent` e `reminder_2h_sent` na tabela `calendar_events`).
- [ ] Garantir que o `lead_id` seja armazenado na descri√ß√£o do evento do Google Calendar ou em uma tabela de mapeamento para recupera√ß√£o.

---

## 4. Problema 3: Gerenciamento de Pipeline no KommoCRM

### 4.1. Diagn√≥stico Detalhado

O agente de IA n√£o est√° movendo os leads entre os est√°gios do pipeline do KommoCRM de forma correta e consistente. A l√≥gica de transi√ß√£o de estado est√° ausente ou falha. As tags e campos customizados tamb√©m n√£o est√£o sendo atualizados de forma confi√°vel.

O arquivo `app/services/kommo_auto_sync.py` √© o principal respons√°vel por essa l√≥gica. A fun√ß√£o `_move_to_correct_stage` provavelmente cont√©m uma l√≥gica de mapeamento incompleta ou incorreta. O `AgenticSDR` tamb√©m precisa ser mais expl√≠cito ao atualizar o `current_stage` do lead no Supabase, que serve como gatilho para a sincroniza√ß√£o.

### 4.2. Plano de A√ß√£o e Solu√ß√£o Proposta

A solu√ß√£o envolve refinar o mapeamento de est√°gios, fortalecer a l√≥gica no `kommo_auto_sync.py` e garantir que o agente principal atualize o estado do lead corretamente.

**Etapa 1: Refinar o Mapeamento de Est√°gios em `kommo_auto_sync.py`**

Assegurar que o `stage_mapping` esteja completo e correto, e que a fun√ß√£o `_move_to_correct_stage` o utilize de forma robusta.

```python
# Em app/services/kommo_auto_sync.py

class KommoAutoSyncService:
    def __init__(self):
        # ...
        # Mapeamento claro e simplificado dos est√°gios
        self.stage_mapping = {
            "INITIAL_CONTACT": "novo_lead",
            "QUALIFYING": "em_qualificacao",
            "SCHEDULING": "reuniao_agendada", # Mover para c√° assim que agendar
            "NOT_INTERESTED": "nao_interessado"
        }
        # ...

    async def _move_to_correct_stage(self, kommo_id: str, lead: Dict[str, Any]):
        """Move o lead para o est√°gio correto no pipeline do Kommo."""
        if not self.crm or not hasattr(self.crm, 'pipeline_stages'):
            logger.warning("CRM ou pipeline_stages n√£o inicializado. Pulando movimenta√ß√£o.")
            return

        current_stage_key = lead.get("current_stage", "INITIAL_CONTACT")
        kommo_stage_name = self.stage_mapping.get(current_stage_key)

        if not kommo_stage_name:
            logger.warning(f"Est√°gio '{current_stage_key}' n√£o mapeado para o Kommo.")
            return

        stage_id = self.crm.pipeline_stages.get(kommo_stage_name)
        if not stage_id:
            logger.error(f"ID do est√°gio '{kommo_stage_name}' n√£o encontrado no Kommo.")
            return

        try:
            await self.crm.move_card_to_pipeline(
                lead_id=kommo_id,
                pipeline_id=settings.kommo_pipeline_id,
                stage_id=stage_id
            )
            logger.info(f"‚úÖ Lead {kommo_id} movido para o est√°gio '{kommo_stage_name}' (ID: {stage_id})")
        except Exception as e:
            logger.error(f"‚ùå Erro ao mover lead {kommo_id} para o est√°gio '{kommo_stage_name}': {e}")

```

**Etapa 2: Ajustar o `AgenticSDR` para Atualizar o `current_stage`**

O agente principal deve atualizar o campo `current_stage` na tabela `leads` do Supabase nos momentos corretos.

-   **Ao receber a primeira resposta do lead:**
    -   Atualizar `current_stage` para `QUALIFYING`.
-   **Ao agendar uma reuni√£o com sucesso:**
    -   Atualizar `current_stage` para `SCHEDULING`.
-   **Ap√≥s 2 follow-ups sem resposta:**
    -   Atualizar `current_stage` para `NOT_INTERESTED`.

**Etapa 3: Revisar o Prompt do Agente**

Adicionar instru√ß√µes claras em `app/prompts/prompt-agente.md` para que o LLM entenda o fluxo do pipeline e saiba quando solicitar a mudan√ßa de est√°gio.

```markdown
# Em app/prompts/prompt-agente.md

## ‚öôÔ∏è FLUXO DE PIPELINE NO KOMMOCRM

Voc√™ deve gerenciar o ciclo de vida do lead no CRM. O sistema mover√° o card automaticamente com base no est√°gio que voc√™ definir.

- **NOVO LEAD**: O sistema define automaticamente.
- **EM QUALIFICA√á√ÉO**: Assim que o lead responder pela primeira vez, mude o est√°gio para 'QUALIFYING'.
- **REUNI√ÉO AGENDADA**: Ap√≥s agendar uma reuni√£o com sucesso, mude o est√°gio para 'SCHEDULING'.
- **N√ÉO INTERESSADO**: Se o lead n√£o responder ap√≥s 2 tentativas de follow-up, mude o est√°gio para 'NOT_INTERESTED'.
```

### 4.3. Checklist de Implementa√ß√£o

- [ ] Revisar e corrigir o `stage_mapping` em `kommo_auto_sync.py`.
- [ ] Fortalecer a l√≥gica de `_move_to_correct_stage` com tratamento de erros.
- [ ] Adicionar l√≥gica no `AgenticSDR` para atualizar o `current_stage` do lead no Supabase em momentos-chave.
- [ ] Atualizar `prompt-agente.md` com as diretrizes do pipeline.
- [ ] Testar o fluxo completo de um lead, desde a cria√ß√£o at√© o agendamento ou desinteresse.

---

## 5. Problema 4: Integra√ß√£o com a Tabela `leads_qualifications` do Supabase

### 5.1. Diagn√≥stico Detalhado

O sistema n√£o est√° inserindo os dados na tabela `leads_qualifications` quando uma reuni√£o √© agendada. A chamada para a inser√ß√£o no banco de dados est√° faltando no fluxo de agendamento. O `CalendarAgent` √© o local mais apropriado para disparar essa a√ß√£o, pois ele √© o respons√°vel por confirmar a cria√ß√£o do evento.

### 5.2. Plano de A√ß√£o e Solu√ß√£o Proposta

A solu√ß√£o √© adicionar uma chamada para uma nova fun√ß√£o no `SupabaseClient` de dentro do m√©todo `schedule_meeting` do `CalendarAgent`, logo ap√≥s o evento ser criado com sucesso no Google Calendar.

**Etapa 1: Criar a fun√ß√£o `create_lead_qualification` em `app/integrations/supabase_client.py`**

```python
# Em app/integrations/supabase_client.py, dentro da classe SupabaseClient

async def create_lead_qualification(self, qualification_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Cria um registro de qualifica√ß√£o de lead.
    """
    try:
        # Valores padr√£o para uma qualifica√ß√£o via agendamento
        defaults = {
            'qualification_status': 'QUALIFIED',
            'score': 85, # Score alto por ter agendado
            'criteria': {'meeting_scheduled': True, 'interest_level': 'high'},
            'notes': 'Lead qualificado via agendamento de reuni√£o pelo agente IA.',
            'qualified_at': datetime.now().isoformat(),
            'created_at': datetime.now().isoformat(),
            'updated_at': datetime.now().isoformat()
        }
        
        # Mescla dados recebidos com os padr√µes
        final_data = {**defaults, **qualification_data}

        # Garante que o lead_id √© um UUID v√°lido se existir
        if 'lead_id' in final_data and isinstance(final_data['lead_id'], str):
            try:
                UUID(final_data['lead_id'], version=4)
            except ValueError:
                logger.error(f"lead_id inv√°lido para qualifica√ß√£o: {final_data['lead_id']}")
                raise ValueError("ID do lead inv√°lido.")

        result = self.client.table('leads_qualifications').insert(final_data).execute()
        
        if result.data:
            logger.info(f"‚úÖ Qualifica√ß√£o criada para o lead {final_data.get('lead_id')}")
            return result.data[0]
        
        raise Exception(f"Erro ao criar qualifica√ß√£o: {result.error.message if result.error else 'sem detalhes'}")

    except Exception as e:
        emoji_logger.supabase_error(f"Erro ao criar qualifica√ß√£o de lead: {str(e)}", table="leads_qualifications")
        raise
```

**Etapa 2: Chamar a nova fun√ß√£o a partir do `CalendarAgent`**

```python
# Em app/teams/agents/calendar.py, dentro do m√©todo schedule_meeting

# ... (ap√≥s a cria√ß√£o do evento no Google Calendar)
if result and result.get("google_event_id"):
    # ... (c√≥digo existente para salvar no banco)

    # >>> IN√çCIO DA NOVA L√ìGICA <<<
    try:
        qualification_data = {
            'lead_id': lead_id,
            'score': 85, # Exemplo de score
            'notes': f"Reuni√£o '{title}' agendada para {date} √†s {time}."
        }
        await supabase_client.create_lead_qualification(qualification_data)
    except Exception as e:
        logger.error(f"Falha ao criar registro de qualifica√ß√£o para o lead {lead_id}: {e}")
        # N√£o interromper o fluxo principal por causa disso
    # >>> FIM DA NOVA L√ìGICA <<<

    logger.info(f"‚úÖ Reuni√£o agendada: {title} em {date} √†s {time}")
    return { ... }
```

### 5.3. Checklist de Implementa√ß√£o

- [ ] Adicionar a fun√ß√£o `create_lead_qualification` √† classe `SupabaseClient`.
- [ ] Adicionar a chamada para `supabase_client.create_lead_qualification` dentro do m√©todo `schedule_meeting` do `CalendarAgent`.
- [ ] Garantir que todos os campos obrigat√≥rios da tabela `leads_qualifications` sejam preenchidos.
- [ ] Testar o agendamento de uma reuni√£o e verificar se o registro correspondente √© criado na tabela.

---

## 6. Problema 5: Erro `TypeError: float()` em `kommo_auto_sync`

### 6.1. Diagn√≥stico Detalhado

O log de erro √© expl√≠cito: `ERROR | app.services.kommo_auto_sync:_create_deal_for_qualified_lead:426 | ‚ùå Erro ao criar deal: float() argument must be a string or a real number, not 'NoneType'`.

Isso significa que na linha 426 do arquivo `app/services/kommo_auto_sync.py`, dentro da fun√ß√£o `_create_deal_for_qualified_lead`, a fun√ß√£o `float()` est√° sendo chamada com um argumento `None`. Analisando o c√≥digo-fonte, a linha problem√°tica √© provavelmente esta:

`value=float(lead.get("bill_value")) * 12`

O erro ocorre quando `lead.get("bill_value")` retorna `None`. Isso pode acontecer se um lead for marcado como qualificado sem que o valor da conta de luz tenha sido registrado no banco de dados.

### 6.2. Plano de A√ß√£o e Solu√ß√£o Proposta

A solu√ß√£o √© adicionar uma verifica√ß√£o defensiva para garantir que `lead.get("bill_value")` n√£o seja `None` antes de pass√°-lo para `float()`. Se for `None`, devemos usar um valor padr√£o (como `0.0`) e talvez logar um aviso.

**Etapa 1: Corrigir a linha 426 em `app/services/kommo_auto_sync.py`**

```python
# Em app/services/kommo_auto_sync.py, na fun√ß√£o _create_deal_for_qualified_lead

# ANTES (Problem√°tico):
# result = await self.crm.create_deal(
#     lead_id=kommo_id,
#     value=float(lead.get("bill_value", 0)) * 12, # O erro pode estar aqui se o valor for None
#     name=f"Solar - {lead.get('name', 'Cliente')}"
# )

# DEPOIS (Corrigido):
bill_value = lead.get("bill_value")
if bill_value is None:
    logger.warning(f"Lead qualificado {lead.get('id')} sem 'bill_value'. Usando 0.0 para o deal.")
    deal_value = 0.0
else:
    try:
        deal_value = float(bill_value) * 12
    except (ValueError, TypeError):
        logger.error(f"N√£o foi poss√≠vel converter 'bill_value' ({bill_value}) para float para o lead {lead.get('id')}. Usando 0.0.")
        deal_value = 0.0

result = await self.crm.create_deal(
    lead_id=kommo_id,
    value=deal_value,
    name=f"Solar - {lead.get('name', 'Cliente')}"
)
```

Esta abordagem √© mais robusta, pois trata explicitamente o caso `None` e tamb√©m poss√≠veis erros de convers√£o, garantindo que o programa n√£o quebre e que o problema seja devidamente registrado.

### 6.3. Checklist de Implementa√ß√£o

- [ ] Localizar a linha exata da chamada `float()` em `_create_deal_for_qualified_lead`.
- [ ] Adicionar uma verifica√ß√£o para `None` antes da convers√£o para `float`.
- [ ] Usar um valor padr√£o (ex: `0.0`) se `bill_value` for `None`.
- [ ] Adicionar um log de aviso (`logger.warning`) para registrar quando essa condi√ß√£o ocorrer.
- [ ] Testar o fluxo com um lead qualificado que intencionalmente n√£o tenha `bill_value` no banco.
