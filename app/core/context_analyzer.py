"""
Context Analyzer - An√°lise SIMPLES de contexto e emo√ß√µes
ZERO complexidade, funcionalidade total
"""
import re
from typing import Dict, Any, List
from app.utils.logger import emoji_logger
from app.config import settings


class ContextAnalyzer:
    """
    Analisador SIMPLES de contexto e estado emocional
    Mant√©m toda a intelig√™ncia de an√°lise conversacional
    """

    def __init__(self):
        self.is_initialized = False
        self.context_enabled = settings.enable_context_analysis
        self.sentiment_enabled = settings.enable_sentiment_analysis
        self.emotional_enabled = settings.enable_emotional_triggers

    def initialize(self):
        """Inicializa√ß√£o simples"""
        if self.is_initialized:
            return

        emoji_logger.system_ready("üß† ContextAnalyzer inicializado")
        self.is_initialized = True

    def analyze_context(self,
                        messages: List[Dict[str, Any]],
                        lead_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analisa contexto da conversa de forma SIMPLES

        Args:
            messages: Hist√≥rico de mensagens
            lead_info: Informa√ß√µes atuais do lead

        Returns:
            An√°lise completa do contexto
        """
        current_message = messages[-1]['content'] if messages else ""
        context = {
            "conversation_stage": self._determine_stage(messages, lead_info),
            "user_intent": self._extract_intent(current_message),
            "sentiment": self._analyze_sentiment(current_message),
            "emotional_state": self._analyze_emotional_state(messages),
            "key_topics": self._extract_topics(messages),
            "urgency_level": self._assess_urgency(current_message),
            "engagement_level": self._calculate_engagement(messages),
            "objections_raised": self._find_objections(messages),
            "questions_asked": self._extract_questions(messages),
            "action_needed": self._determine_action(current_message)
        }

        return context

    def _determine_stage(self, messages: List[Dict[str, Any]], lead_info: Dict[str, Any]) -> str:
        """
        Determina est√°gio da conversa baseado no conte√∫do e no estado do lead

        Args:
            messages: Hist√≥rico
            lead_info: Informa√ß√µes do lead

        Returns:
            Est√°gio atual
        """
        has_name = bool(lead_info.get("name"))
        has_solutions_presented = False
        has_choice = False

        user_count = sum(1 for m in messages if m.get("role") == "user")
        assistant_count = sum(
            1 for m in messages if m.get("role") == "assistant"
        )
        emoji_logger.conversation_event(
            f"üìä Analisando est√°gio - Msgs: {len(messages)} "
            f"(üë§ {user_count} user, ü§ñ {assistant_count} assistant)"
        )

        # Se o nome ainda n√£o foi coletado pelo lead_info, tenta extrair do hist√≥rico
        if not has_name:
            for msg in messages:
                content = msg.get("content", "").lower()
                role = msg.get("role", "")

                if role == "user":
                    # Verifica padr√µes expl√≠citos de nome
                    if any(re.search(r'\b' + pattern + r'\b', content) for pattern in ["meu nome √©", "me chamo", "sou o", "sou a"]):
                        has_name = True
                        break
                    # Verifica se a mensagem anterior foi uma pergunta sobre o nome
                    elif len(messages) > 1:
                        prev_msg_index = messages.index(msg) - 1
                        if prev_msg_index >= 0:
                            prev_msg = messages[prev_msg_index]
                            prev_content = prev_msg.get("content", "").lower()
                            # Padr√µes de pergunta sobre nome
                            name_questions = ["como posso te chamar", "qual seu nome", "como se chama"]
                            if prev_msg.get("role") == "assistant" and any(q in prev_content for q in name_questions):
                                # Se a resposta for curta (1-3 palavras), assume que √© o nome
                                if 1 <= len(content.split()) <= 3:
                                    has_name = True
                                    break
        
        # Continua a an√°lise do hist√≥rico para os outros est√°gios
        for msg in messages:
            content = msg.get("content", "").lower()
            role = msg.get("role", "")

            if role == "assistant" and all(
                sol in content for sol in [
                    "instala√ß√£o", "aluguel", "compra", "investimento"
                ]
            ):
                has_solutions_presented = True

            if role == "user" and any(word in content for word in [
                "op√ß√£o", "primeira", "segunda", "terceira", "quarta",
                "instala√ß√£o", "aluguel", "compra", "investimento"
            ]):
                has_choice = True

        # L√≥gica de decis√£o de est√°gio
        if messages:
            last_message = messages[-1]
            if last_message.get("role") == "assistant":
                last_content = last_message.get("content", "").lower()
                if any(q in last_content for q in ["marcar uma reuni√£o", "quando podemos marcar", "quando voc√™ estaria dispon√≠vel"]):
                    return "agendamento"

        if not has_name:
            return "est√°gio_0_coleta_nome"
        elif has_name and not has_solutions_presented:
            return "est√°gio_1_apresentar_solu√ß√µes"
        elif has_solutions_presented and not has_choice:
            return "est√°gio_2_aguardando_escolha"
        elif has_choice:
            return "qualifica√ß√£o"
        else:
            msg_count = len(messages)
            if msg_count <= 2:
                return "in√≠cio"
            elif msg_count <= 10:
                return "explora√ß√£o"
            else:
                return "negocia√ß√£o"

    def _extract_intent(self, message: str) -> str:
        """
        Extrai inten√ß√£o principal da mensagem

        Args:
            message: Mensagem

        Returns:
            Inten√ß√£o identificada
        """
        message_lower = message.lower()

        intents = {
            "informa√ß√£o": [
                "quanto", "como", "qual", "quando", "onde", "quem"
            ],
            "interesse": [
                "quero", "gostaria", "interessado", "me interessa"
            ],
            "d√∫vida": ["ser√°", "n√£o sei", "talvez", "d√∫vida"],
            "obje√ß√£o": ["caro", "dif√≠cil", "problema", "n√£o posso"],
            "agendamento": ["agendar", "marcar", "reuni√£o", "conversar"],
            "compra": ["comprar", "adquirir", "fechar", "contratar"],
            "reclama√ß√£o": ["ruim", "p√©ssimo", "horr√≠vel", "insatisfeito"],
            "elogio": ["√≥timo", "excelente", "muito bom", "adorei"]
        }

        for intent, keywords in intents.items():
            if any(keyword in message_lower for keyword in keywords):
                return intent

        return "conversa"

    def _analyze_sentiment(self, message: str) -> Dict[str, Any]:
        """
        Analisa sentimento da mensagem

        Args:
            message: Mensagem

        Returns:
            An√°lise de sentimento
        """
        if not self.sentiment_enabled:
            return {"enabled": False}

        message_lower = message.lower()

        positive_words = [
            "bom", "√≥timo", "excelente", "legal", "maravilha",
            "perfeito", "adorei", "gostei", "sim", "quero"
        ]
        negative_words = [
            "ruim", "p√©ssimo", "horr√≠vel", "n√£o", "nunca",
            "problema", "dif√≠cil", "caro", "d√∫vida", "medo"
        ]

        positive_count = sum(
            1 for word in positive_words if word in message_lower
        )
        negative_count = sum(
            1 for word in negative_words if word in message_lower
        )

        if positive_count > negative_count:
            sentiment = "positivo"
            score = min(1.0, positive_count * 0.2)
        elif negative_count > positive_count:
            sentiment = "negativo"
            score = max(-1.0, -negative_count * 0.2)
        else:
            sentiment = "neutro"
            score = 0.0

        return {
            "enabled": True,
            "sentiment": sentiment,
            "score": score,
            "confidence": 0.7
        }

    def _analyze_emotional_state(
            self, messages: List[Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Analisa estado emocional do usu√°rio

        Args:
            messages: Hist√≥rico

        Returns:
            Estado emocional
        """
        if not self.emotional_enabled:
            return {"enabled": False}

        emotions = {
            "frustra√ß√£o": 0, "entusiasmo": 0, "hesita√ß√£o": 0,
            "urg√™ncia": 0, "confian√ßa": 0
        }

        recent_messages = messages[-5:]

        for msg in recent_messages:
            content = msg.get("content", "").lower()

            if any(word in content for word in [
                "demora", "dif√≠cil", "complicado"
            ]):
                emotions["frustra√ß√£o"] += 1

            if any(word in content for word in ["√≥timo", "excelente", "adorei"]):
                emotions["entusiasmo"] += 1

            if any(word in content for word in ["n√£o sei", "talvez", "pensar"]):
                emotions["hesita√ß√£o"] += 1

            if any(word in content for word in ["urgente", "r√°pido", "agora"]):
                emotions["urg√™ncia"] += 1

            if any(word in content for word in ["confio", "acredito", "certeza"]):
                emotions["confian√ßa"] += 1

        dominant_emotion = max(emotions.items(), key=lambda x: x[1])

        return {
            "enabled": True,
            "dominant": (
                dominant_emotion[0] if dominant_emotion[1] > 0 else "neutro"
            ),
            "scores": emotions,
            "intensity": min(1.0, dominant_emotion[1] * 0.3)
        }

    def _extract_topics(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Extrai t√≥picos principais da conversa

        Args:
            messages: Hist√≥rico

        Returns:
            Lista de t√≥picos
        """
        topics = []
        topic_keywords = {
            "economia": ["economizar", "conta", "valor", "pagar"],
            "energia_solar": ["solar", "painel", "energia", "sol"],
            "investimento": ["investir", "retorno", "prazo", "custo"],
            "instala√ß√£o": ["instalar", "obra", "telhado", "espa√ßo"],
            "financiamento": ["financiar", "parcelar", "entrada", "prazo"],
            "manuten√ß√£o": [
                "manuten√ß√£o", "garantia", "durabilidade", "vida √∫til"
            ],
            "sustentabilidade": ["sustent√°vel", "ambiente", "verde", "limpa"]
        }

        all_text = " ".join(
            [msg.get("content", "") for msg in messages]
        ).lower()

        for topic, keywords in topic_keywords.items():
            if any(keyword in all_text for keyword in keywords):
                topics.append(topic)

        return topics

    def _assess_urgency(self, message: str) -> str:
        """
        Avalia n√≠vel de urg√™ncia

        Args:
            message: Mensagem

        Returns:
            N√≠vel de urg√™ncia
        """
        message_lower = message.lower()
        high_urgency = ["urgente", "agora", "hoje", "imediatamente", "r√°pido"]
        medium_urgency = ["amanh√£", "semana", "breve", "logo"]
        low_urgency = ["futuro", "depois", "talvez", "pensando"]

        if any(word in message_lower for word in high_urgency):
            return "alta"
        elif any(word in message_lower for word in medium_urgency):
            return "m√©dia"
        elif any(word in message_lower for word in low_urgency):
            return "baixa"
        else:
            return "normal"

    def _calculate_engagement(self, messages: List[Dict[str, Any]]) -> float:
        """
        Calcula n√≠vel de engajamento

        Args:
            messages: Hist√≥rico

        Returns:
            Score de engajamento (0-1)
        """
        if len(messages) < 2:
            return 0.5

        factors = {
            "message_count": min(1.0, len(messages) / 20),
            "avg_length": 0,
            "questions": 0,
            "response_time": 0.5
        }

        avg_length = sum(
            len(msg.get("content", "")) for msg in messages
        ) / len(messages)
        factors["avg_length"] = min(1.0, avg_length / 100)

        question_count = sum(
            1 for msg in messages if "?" in msg.get("content", "")
        )
        factors["questions"] = min(1.0, question_count / 5)

        engagement = sum(factors.values()) / len(factors)
        return engagement

    def _find_objections(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Encontra obje√ß√µes mencionadas

        Args:
            messages: Hist√≥rico

        Returns:
            Lista de obje√ß√µes
        """
        objections = []
        objection_patterns = {
            "pre√ßo": ["muito caro", "n√£o tenho dinheiro", "fora do or√ßamento"],
            "desconfian√ßa": ["n√£o confio", "√© golpe", "parece suspeito"],
            "timing": ["n√£o √© o momento", "depois eu vejo", "agora n√£o"],
            "propriedade": ["casa alugada", "n√£o sou dono", "inquilino"],
            "tecnologia": ["n√£o entendo", "muito complicado", "dif√≠cil"]
        }

        all_text = " ".join(
            [msg.get("content", "") for msg in messages]
        ).lower()

        for objection, patterns in objection_patterns.items():
            if any(pattern in all_text for pattern in patterns):
                objections.append(objection)

        return objections

    def _extract_questions(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Extrai perguntas feitas

        Args:
            messages: Hist√≥rico

        Returns:
            Lista de perguntas
        """
        questions = []
        for msg in messages:
            content = msg.get("content", "")
            if "?" in content:
                question = content.split("?")[0][-100:] + "?"
                questions.append(question.strip())
        return questions[-5:]

    def _determine_action(self, message: str) -> str:
        """
        Determina a√ß√£o necess√°ria

        Args:
            message: Mensagem

        Returns:
            A√ß√£o recomendada
        """
        message_lower = message.lower()
        actions = {
            "agendar": [
                "agendar", "marcar", "reuni√£o", "conversar", "leonardo"
            ],
            "qualificar": ["conta", "valor", "gasto", "consumo", "kwh"],
            "informar": [
                "como funciona", "quanto custa", "d√∫vida", "explicar"
            ],
            "fechar": ["quero", "fechar", "contratar", "assinar"],
            "reengajar": ["pensar", "depois", "talvez", "n√£o sei"]
        }

        for action, keywords in actions.items():
            if any(keyword in message_lower for keyword in keywords):
                return action

        return "conversar"

    def get_context_summary(self, context: Dict[str, Any]) -> str:
        """
        Gera resumo do contexto

        Args:
            context: An√°lise de contexto

        Returns:
            Resumo formatado
        """
        summary = "üìä **An√°lise de Contexto**\n\n"
        summary += f"üéØ Est√°gio: {context['conversation_stage']}\n"
        summary += f"üí≠ Inten√ß√£o: {context['user_intent']}\n"

        if context['sentiment'].get('enabled'):
            summary += f"üòä Sentimento: {context['sentiment']['sentiment']}\n"

        if context['emotional_state'].get('enabled'):
            summary += f"‚ù§Ô∏è Emo√ß√£o: {context['emotional_state']['dominant']}\n"

        summary += f"‚ö° Urg√™ncia: {context['urgency_level']}\n"
        summary += f"üìà Engajamento: {context['engagement_level']:.0%}\n"
        summary += f"üé¨ A√ß√£o: {context['action_needed']}\n"

        if context['key_topics']:
            summary += f"\nüìå T√≥picos: {', '.join(context['key_topics'])}\n"

        if context['objections_raised']:
            summary += f"‚ö†Ô∏è Obje√ß√µes: {', '.join(context['objections_raised'])}\n"

        return summary
