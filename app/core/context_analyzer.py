"""
Context Analyzer - An√°lise SIMPLES de contexto e emo√ß√µes
ZERO complexidade, funcionalidade total
"""

from typing import Dict, Any, List, Optional
from datetime import datetime
from app.utils.logger import emoji_logger
from app.config import settings

class ContextAnalyzer:
    """
    Analisador SIMPLES de contexto e estado emocional
    Mant√©m toda a intelig√™ncia de an√°lise conversacional
    """
    
    def __init__(self):
        self.is_initialized = False
        self.context_enabled = settings.enable_context_analysis
        self.sentiment_enabled = settings.enable_sentiment_analysis
        self.emotional_enabled = settings.enable_emotional_triggers
        
    def initialize(self):
        """Inicializa√ß√£o simples"""
        if self.is_initialized:
            return
            
        emoji_logger.system_ready("üß† ContextAnalyzer inicializado")
        self.is_initialized = True
    
    def analyze_context(self, 
                        messages: List[Dict[str, Any]],
                        current_message: str) -> Dict[str, Any]:
        """
        Analisa contexto da conversa de forma SIMPLES
        
        Args:
            messages: Hist√≥rico de mensagens
            current_message: Mensagem atual
            
        Returns:
            An√°lise completa do contexto
        """
        context = {
            "conversation_stage": self._determine_stage(messages),
            "user_intent": self._extract_intent(current_message),
            "sentiment": self._analyze_sentiment(current_message),
            "emotional_state": self._analyze_emotional_state(messages),
            "key_topics": self._extract_topics(messages),
            "urgency_level": self._assess_urgency(current_message),
            "engagement_level": self._calculate_engagement(messages),
            "objections_raised": self._find_objections(messages),
            "questions_asked": self._extract_questions(messages),
            "action_needed": self._determine_action(current_message)
        }
        
        return context
    
    def _determine_stage(self, messages: List[Dict[str, Any]]) -> str:
        """
        Determina est√°gio da conversa baseado no conte√∫do
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Est√°gio atual
        """
        # Analisar conte√∫do das mensagens para determinar est√°gio
        has_name = False
        has_solutions_presented = False
        has_choice = False
        
        for msg in messages:
            content = msg.get("content", "").lower()
            role = msg.get("role", "")
            
            # Verificar se tem nome do lead
            if role == "user":
                # Padr√µes expl√≠citos de nome
                if any(word in content for word in ["meu nome √©", "me chamo", "sou o", "sou a", "pode me chamar de"]):
                    has_name = True
                    # emoji_logger.info(f"‚úÖ Nome detectado por padr√£o expl√≠cito em: '{content[:50]}...'")
                # Se a mensagem anterior perguntou o nome, a pr√≥xima resposta provavelmente √© o nome
                elif len(messages) > 1:
                    prev_idx = messages.index(msg) - 1
                    if prev_idx >= 0:
                        prev_msg = messages[prev_idx]
                        prev_content = prev_msg.get("content", "").lower()
                        
                        # Lista de perguntas sobre nome
                        name_questions = [
                            "como posso te chamar",
                            "como posso chamar", 
                            "qual seu nome",
                            "qual √© seu nome",
                            "posso saber seu nome"
                        ]
                        
                        if prev_msg.get("role") == "assistant" and any(q in prev_content for q in name_questions):
                            # Esta mensagem √© provavelmente um nome
                            words = content.split()
                            if 1 <= len(words) <= 4:  # Nomes geralmente s√£o curtos
                                # Verificar blacklist
                                blacklist = ["oi", "ol√°", "sim", "n√£o", "ok", "tudo", "bem", "bom", "dia"]
                                if not any(w in blacklist for w in words):
                                    has_name = True
                                    # emoji_logger.info(f"‚úÖ Nome detectado por contexto: '{content}'")
                                # else:
                                #     emoji_logger.info(f"‚ùå Potencial nome rejeitado (blacklist): '{content}'")
            
            # Verificar se as 4 solu√ß√µes foram apresentadas
            if role == "assistant" and all(sol in content for sol in ["instala√ß√£o", "aluguel", "compra", "investimento"]):
                has_solutions_presented = True
            
            # Verificar se lead escolheu uma op√ß√£o
            if role == "user" and any(word in content for word in ["op√ß√£o", "primeira", "segunda", "terceira", "quarta", "instala√ß√£o", "aluguel", "compra", "investimento"]):
                has_choice = True
        
        # Determinar est√°gio baseado no progresso
        if not has_name:
            return "est√°gio_0_coleta_nome"
        elif has_name and not has_solutions_presented:
            return "est√°gio_1_apresentar_solu√ß√µes"
        elif has_solutions_presented and not has_choice:
            return "est√°gio_2_aguardando_escolha"
        elif has_choice:
            return "qualifica√ß√£o"
        else:
            # Fallback para contagem de mensagens
            msg_count = len(messages)
            if msg_count <= 2:
                return "in√≠cio"
            elif msg_count <= 10:
                return "explora√ß√£o"
            else:
                return "negocia√ß√£o"
    
    def _extract_intent(self, message: str) -> str:
        """
        Extrai inten√ß√£o principal da mensagem
        
        Args:
            message: Mensagem
            
        Returns:
            Inten√ß√£o identificada
        """
        message_lower = message.lower()
        
        # Mapear inten√ß√µes
        intents = {
            "informa√ß√£o": ["quanto", "como", "qual", "quando", "onde", "quem"],
            "interesse": ["quero", "gostaria", "interessado", "me interessa"],
            "d√∫vida": ["ser√°", "n√£o sei", "talvez", "d√∫vida"],
            "obje√ß√£o": ["caro", "dif√≠cil", "problema", "n√£o posso"],
            "agendamento": ["agendar", "marcar", "reuni√£o", "conversar"],
            "compra": ["comprar", "adquirir", "fechar", "contratar"],
            "reclama√ß√£o": ["ruim", "p√©ssimo", "horr√≠vel", "insatisfeito"],
            "elogio": ["√≥timo", "excelente", "muito bom", "adorei"]
        }
        
        for intent, keywords in intents.items():
            if any(keyword in message_lower for keyword in keywords):
                return intent
        
        return "conversa"
    
    def _analyze_sentiment(self, message: str) -> Dict[str, Any]:
        """
        Analisa sentimento da mensagem
        
        Args:
            message: Mensagem
            
        Returns:
            An√°lise de sentimento
        """
        if not self.sentiment_enabled:
            return {"enabled": False}
        
        message_lower = message.lower()
        
        # Palavras positivas e negativas
        positive_words = ["bom", "√≥timo", "excelente", "legal", "maravilha", 
                         "perfeito", "adorei", "gostei", "sim", "quero"]
        negative_words = ["ruim", "p√©ssimo", "horr√≠vel", "n√£o", "nunca",
                         "problema", "dif√≠cil", "caro", "d√∫vida", "medo"]
        
        positive_count = sum(1 for word in positive_words if word in message_lower)
        negative_count = sum(1 for word in negative_words if word in message_lower)
        
        # Calcular sentimento
        if positive_count > negative_count:
            sentiment = "positivo"
            score = min(1.0, positive_count * 0.2)
        elif negative_count > positive_count:
            sentiment = "negativo"
            score = max(-1.0, -negative_count * 0.2)
        else:
            sentiment = "neutro"
            score = 0.0
        
        return {
            "enabled": True,
            "sentiment": sentiment,
            "score": score,
            "confidence": 0.7  # Confian√ßa m√©dia
        }
    
    def _analyze_emotional_state(self, messages: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analisa estado emocional do usu√°rio
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Estado emocional
        """
        if not self.emotional_enabled:
            return {"enabled": False}
        
        emotions = {
            "frustra√ß√£o": 0,
            "entusiasmo": 0,
            "hesita√ß√£o": 0,
            "urg√™ncia": 0,
            "confian√ßa": 0
        }
        
        # Analisar √∫ltimas mensagens
        recent_messages = messages[-5:] if len(messages) > 5 else messages
        
        for msg in recent_messages:
            content = msg.get("content", "").lower()
            
            # Detectar emo√ß√µes
            if any(word in content for word in ["demora", "dif√≠cil", "complicado"]):
                emotions["frustra√ß√£o"] += 1
            
            if any(word in content for word in ["√≥timo", "excelente", "adorei"]):
                emotions["entusiasmo"] += 1
            
            if any(word in content for word in ["n√£o sei", "talvez", "pensar"]):
                emotions["hesita√ß√£o"] += 1
            
            if any(word in content for word in ["urgente", "r√°pido", "agora"]):
                emotions["urg√™ncia"] += 1
            
            if any(word in content for word in ["confio", "acredito", "certeza"]):
                emotions["confian√ßa"] += 1
        
        # Determinar emo√ß√£o dominante
        dominant_emotion = max(emotions.items(), key=lambda x: x[1])
        
        return {
            "enabled": True,
            "dominant": dominant_emotion[0] if dominant_emotion[1] > 0 else "neutro",
            "scores": emotions,
            "intensity": min(1.0, dominant_emotion[1] * 0.3)
        }
    
    def _extract_topics(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Extrai t√≥picos principais da conversa
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Lista de t√≥picos
        """
        topics = []
        
        topic_keywords = {
            "economia": ["economizar", "conta", "valor", "pagar"],
            "energia_solar": ["solar", "painel", "energia", "sol"],
            "investimento": ["investir", "retorno", "prazo", "custo"],
            "instala√ß√£o": ["instalar", "obra", "telhado", "espa√ßo"],
            "financiamento": ["financiar", "parcelar", "entrada", "prazo"],
            "manuten√ß√£o": ["manuten√ß√£o", "garantia", "durabilidade", "vida √∫til"],
            "sustentabilidade": ["sustent√°vel", "ambiente", "verde", "limpa"]
        }
        
        # Analisar todas as mensagens
        all_text = " ".join([msg.get("content", "") for msg in messages]).lower()
        
        for topic, keywords in topic_keywords.items():
            if any(keyword in all_text for keyword in keywords):
                topics.append(topic)
        
        return topics
    
    def _assess_urgency(self, message: str) -> str:
        """
        Avalia n√≠vel de urg√™ncia
        
        Args:
            message: Mensagem
            
        Returns:
            N√≠vel de urg√™ncia
        """
        message_lower = message.lower()
        
        high_urgency = ["urgente", "agora", "hoje", "imediatamente", "r√°pido"]
        medium_urgency = ["amanh√£", "semana", "breve", "logo"]
        low_urgency = ["futuro", "depois", "talvez", "pensando"]
        
        if any(word in message_lower for word in high_urgency):
            return "alta"
        elif any(word in message_lower for word in medium_urgency):
            return "m√©dia"
        elif any(word in message_lower for word in low_urgency):
            return "baixa"
        else:
            return "normal"
    
    def _calculate_engagement(self, messages: List[Dict[str, Any]]) -> float:
        """
        Calcula n√≠vel de engajamento
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Score de engajamento (0-1)
        """
        if len(messages) < 2:
            return 0.5
        
        # Fatores de engajamento
        factors = {
            "message_count": min(1.0, len(messages) / 20),  # Mais mensagens = mais engajado
            "avg_length": 0,  # Mensagens mais longas = mais engajado
            "questions": 0,  # Mais perguntas = mais interesse
            "response_time": 0.5  # Placeholder para tempo de resposta
        }
        
        # Calcular comprimento m√©dio
        avg_length = sum(len(msg.get("content", "")) for msg in messages) / len(messages)
        factors["avg_length"] = min(1.0, avg_length / 100)
        
        # Contar perguntas
        question_count = sum(1 for msg in messages if "?" in msg.get("content", ""))
        factors["questions"] = min(1.0, question_count / 5)
        
        # Calcular score final
        engagement = sum(factors.values()) / len(factors)
        
        return engagement
    
    def _find_objections(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Encontra obje√ß√µes mencionadas
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Lista de obje√ß√µes
        """
        objections = []
        
        objection_patterns = {
            "pre√ßo": ["muito caro", "n√£o tenho dinheiro", "fora do or√ßamento"],
            "desconfian√ßa": ["n√£o confio", "√© golpe", "parece suspeito"],
            "timing": ["n√£o √© o momento", "depois eu vejo", "agora n√£o"],
            "propriedade": ["casa alugada", "n√£o sou dono", "inquilino"],
            "tecnologia": ["n√£o entendo", "muito complicado", "dif√≠cil"]
        }
        
        all_text = " ".join([msg.get("content", "") for msg in messages]).lower()
        
        for objection, patterns in objection_patterns.items():
            if any(pattern in all_text for pattern in patterns):
                objections.append(objection)
        
        return objections
    
    def _extract_questions(self, messages: List[Dict[str, Any]]) -> List[str]:
        """
        Extrai perguntas feitas
        
        Args:
            messages: Hist√≥rico
            
        Returns:
            Lista de perguntas
        """
        questions = []
        
        for msg in messages:
            content = msg.get("content", "")
            if "?" in content:
                # Extrair apenas a pergunta (at√© 100 caracteres)
                question = content.split("?")[0][-100:] + "?"
                questions.append(question.strip())
        
        return questions[-5:]  # √öltimas 5 perguntas
    
    def _determine_action(self, message: str) -> str:
        """
        Determina a√ß√£o necess√°ria
        
        Args:
            message: Mensagem
            
        Returns:
            A√ß√£o recomendada
        """
        message_lower = message.lower()
        
        actions = {
            "agendar": ["agendar", "marcar", "reuni√£o", "conversar", "leonardo"],
            "qualificar": ["conta", "valor", "gasto", "consumo", "kwh"],
            "informar": ["como funciona", "quanto custa", "d√∫vida", "explicar"],
            "fechar": ["quero", "fechar", "contratar", "assinar"],
            "reengajar": ["pensar", "depois", "talvez", "n√£o sei"]
        }
        
        for action, keywords in actions.items():
            if any(keyword in message_lower for keyword in keywords):
                return action
        
        return "conversar"
    
    def get_context_summary(self, context: Dict[str, Any]) -> str:
        """
        Gera resumo do contexto
        
        Args:
            context: An√°lise de contexto
            
        Returns:
            Resumo formatado
        """
        summary = "üìä **An√°lise de Contexto**\n\n"
        
        summary += f"üéØ Est√°gio: {context['conversation_stage']}\n"
        summary += f"üí≠ Inten√ß√£o: {context['user_intent']}\n"
        
        if context['sentiment'].get('enabled'):
            summary += f"üòä Sentimento: {context['sentiment']['sentiment']}\n"
        
        if context['emotional_state'].get('enabled'):
            summary += f"‚ù§Ô∏è Emo√ß√£o: {context['emotional_state']['dominant']}\n"
        
        summary += f"‚ö° Urg√™ncia: {context['urgency_level']}\n"
        summary += f"üìà Engajamento: {context['engagement_level']:.0%}\n"
        summary += f"üé¨ A√ß√£o: {context['action_needed']}\n"
        
        if context['key_topics']:
            summary += f"\nüìå T√≥picos: {', '.join(context['key_topics'])}\n"
        
        if context['objections_raised']:
            summary += f"‚ö†Ô∏è Obje√ß√µes: {', '.join(context['objections_raised'])}\n"
        
        return summary